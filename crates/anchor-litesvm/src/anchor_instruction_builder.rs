//! Native Anchor instruction builder that works directly with types generated by
//! `anchor_lang::declare_program!` without requiring anchor-client or RPC connections.

use anchor_lang::{InstructionData, ToAccountMetas};
use solana_program::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
};

/// A lightweight builder for creating Anchor instructions without RPC overhead.
///
/// This builder works directly with the types generated by `anchor_lang::declare_program!`,
/// providing a clean API for constructing instructions in tests without the complexity
/// of anchor-client's RPC infrastructure.
///
/// # Example
///
/// ```ignore
/// // With anchor_lang::declare_program!(my_program);
///
/// let ix = AnchorInstructionBuilder::new(program_id)
///     .accounts(my_program::client::accounts::MyInstruction {
///         user: user_pubkey,
///         account: account_pubkey,
///         system_program: system_program::id(),
///     })
///     .args(my_program::client::args::MyInstruction {
///         amount: 100,
///     })
///     .build();
/// ```
pub struct AnchorInstructionBuilder {
    program_id: Pubkey,
    accounts: Vec<AccountMeta>,
    data: Vec<u8>,
}

impl AnchorInstructionBuilder {
    /// Create a new instruction builder for the given program ID.
    pub fn new(program_id: Pubkey) -> Self {
        Self {
            program_id,
            accounts: Vec::new(),
            data: Vec::new(),
        }
    }

    /// Set the accounts for this instruction.
    ///
    /// The accounts parameter should be a struct generated by `declare_program!`
    /// that implements the `ToAccountMetas` trait.
    pub fn accounts<T: ToAccountMetas>(mut self, accounts: T) -> Self {
        self.accounts = accounts.to_account_metas(None);
        self
    }

    /// Set the instruction arguments.
    ///
    /// The args parameter should be a struct generated by `declare_program!`
    /// that implements the `InstructionData` trait. This automatically handles
    /// the discriminator and serialization.
    pub fn args<T: InstructionData>(mut self, args: T) -> Self {
        self.data = args.data();
        self
    }

    /// Build the final instruction.
    ///
    /// Returns a Solana instruction that can be executed directly with LiteSVM.
    pub fn build(self) -> Instruction {
        Instruction {
            program_id: self.program_id,
            accounts: self.accounts,
            data: self.data,
        }
    }

    /// Build and return the instruction, consuming the builder.
    ///
    /// This is an alias for `build()` for ergonomics.
    pub fn instruction(self) -> Instruction {
        self.build()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anchor_lang::prelude::*;

    // Mock types that would normally be generated by declare_program!
    struct TestAccounts {
        user: Pubkey,
        account: Pubkey,
    }

    impl ToAccountMetas for TestAccounts {
        fn to_account_metas(&self, _is_signer: Option<bool>) -> Vec<AccountMeta> {
            vec![
                AccountMeta::new(self.user, true),
                AccountMeta::new(self.account, false),
            ]
        }
    }

    #[derive(AnchorSerialize, AnchorDeserialize)]
    struct TestArgs {
        amount: u64,
    }

    impl anchor_lang::Discriminator for TestArgs {
        const DISCRIMINATOR: &'static [u8] = &[1, 2, 3, 4, 5, 6, 7, 8];
    }

    impl InstructionData for TestArgs {
        fn data(&self) -> Vec<u8> {
            let mut data = Vec::new();
            data.extend_from_slice(Self::DISCRIMINATOR);
            self.serialize(&mut data).unwrap();
            data
        }
    }

    #[test]
    fn test_builder_basic() {
        let program_id = Pubkey::new_unique();
        let user = Pubkey::new_unique();
        let account = Pubkey::new_unique();

        let ix = AnchorInstructionBuilder::new(program_id)
            .accounts(TestAccounts { user, account })
            .args(TestArgs { amount: 100 })
            .build();

        assert_eq!(ix.program_id, program_id);
        assert_eq!(ix.accounts.len(), 2);
        assert_eq!(ix.accounts[0].pubkey, user);
        assert!(ix.accounts[0].is_signer);
        assert_eq!(ix.accounts[1].pubkey, account);
        assert!(!ix.accounts[1].is_signer);
        assert!(ix.data.len() > 8); // At least discriminator + data
    }
}